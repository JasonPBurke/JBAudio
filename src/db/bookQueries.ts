import database from '@/db';
import Book from '@/db/models/Book';
import Author from '@/db/models/Author';
import Chapter from '@/db/models/Chapter';
import { BookEditableFields, Chapter as ChapterType } from '@/types/Book';
import { Q, Query, Relation } from '@nozbe/watermelondb';
import { Observable } from 'rxjs';

/**
 * Data structure returned for position restoration.
 * Contains only the fields needed by useSetupTrackPlayer.
 */
export interface BookRestorationData {
  bookId: string;
  bookTitle: string;
  author: string;
  artwork: string | null;
  bookDuration: number;
  chapters: ChapterType[];
}

/**
 * Fetches book and chapters directly from WatermelonDB for position restoration.
 * Bypasses Zustand to avoid race conditions during app startup.
 *
 * @param bookId - The ID of the book to fetch
 * @returns Book data with sorted chapters, or null if not found
 */
export async function getBookWithChaptersForRestoration(
  bookId: string
): Promise<BookRestorationData | null> {
  try {
    const book = await database.get<Book>('books').find(bookId);
    if (!book) return null;

    // Fetch chapters via the children relation
    const chaptersCollection = database.get<Chapter>('chapters');
    const chapters = await chaptersCollection
      .query(Q.where('book_id', bookId))
      .fetch();

    // Fetch author name
    const authorRelation = book.author as unknown as Relation<Author>;
    const author = await authorRelation.fetch();
    const authorName = author?.name ?? 'Unknown Author';

    // Transform DB chapters to the ChapterType format expected by the app
    // Sort by startMs to ensure consistent ordering for single-file books
    const transformedChapters: ChapterType[] = chapters
      .map((ch) => ({
        author: authorName,
        bookTitle: book.title,
        chapterTitle: ch.title,
        chapterNumber: ch.chapterNumber,
        chapterDuration: ch.chapterDuration,
        startMs: ch.startMs ?? 0,
        url: ch.url,
        isAutoGenerated: ch.isAutoGenerated ?? false,
      }))
      .sort((a, b) => (a.startMs ?? 0) - (b.startMs ?? 0));

    return {
      bookId: book.id,
      bookTitle: book.title,
      author: authorName,
      artwork: book.artwork,
      bookDuration: book.bookDuration,
      chapters: transformedChapters,
    };
  } catch (error) {
    // Book not found or database error
    console.error(`getBookWithChaptersForRestoration: Error for ${bookId}`, error);
    return null;
  }
}

export function observeTotalBookCount(): Observable<number> {
  const booksCollection = database.collections.get<Book>('books');
  return booksCollection.query().observeCount(false);
}

export async function getTotalBookCount(): Promise<number> {
  const booksCollection = database.collections.get<Book>('books');
  const count = await booksCollection.query().fetchCount();
  return count;
}

export async function getBookProgressValue(
  bookId: string
): Promise<number> {
  const book = (await database.collections
    .get('books')
    .find(bookId)) as Book;

  return book.bookProgressValue;
}

export const getBookById = async (bookId: string): Promise<Book | null> => {
  try {
    const book = await database.get<Book>('books').find(bookId);
    return book;
  } catch (error) {
    // This will catch if the book is not found
    console.error(`Book with id ${bookId} not found.`, error);
    return null;
  }
};

export const updateBookDetails = async (
  bookId: string,
  details: Partial<BookEditableFields>
) => {
  await database.write(async () => {
    try {
      const book = await database.get<Book>('books').find(bookId);
      const authorRelation = book.author as unknown as Relation<Author>;
      const currentAuthor = await authorRelation.fetch();
      const currentAuthorName = currentAuthor?.name ?? '';

      // Handle author change
      const trimmedAuthorName = details.author?.trim();
      if (
        trimmedAuthorName &&
        trimmedAuthorName.toLowerCase() !== currentAuthorName.toLowerCase()
      ) {
        // Find existing author by name (case-insensitive)
        const existingAuthors = await database
          .get<Author>('authors')
          .query()
          .fetch();

        let newAuthor = existingAuthors.find(
          (a) => a.name.toLowerCase() === trimmedAuthorName.toLowerCase()
        );

        // Create author if doesn't exist
        if (!newAuthor) {
          newAuthor = await database
            .get<Author>('authors')
            .create((author) => {
              author.name = trimmedAuthorName;
            });
        }

        // Update book's author relation
        await book.update((b) => {
          (b.author as unknown as Relation<Author>).set(newAuthor!);
        });

        // Clean up orphaned old author
        if (currentAuthor) {
          const booksQuery = currentAuthor.books as unknown as Query<Book>;
          const remainingBooks = await booksQuery
            .extend(Q.where('id', Q.notEq(bookId)))
            .fetchCount();
          if (remainingBooks === 0) {
            await currentAuthor.markAsDeleted();
          }
        }
      }

      // Update other book fields
      await book.update((b) => {
        b.title = details.bookTitle ?? b.title;
        b.narrator = details.narrator ?? b.narrator;
        b.genre = details.genre ?? b.genre;
        b.year = details.year ? parseInt(details.year, 10) : b.year;
        b.description = details.description ?? b.description;
        b.copyright = details.copyright ?? b.copyright;
      });
    } catch (error) {
      console.error('Error updating book details:', error);
    }
  });
};
