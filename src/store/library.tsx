import { Author, Book, Chapter } from '@/types/Book';
import { create, StoreApi, UseBoundStore } from 'zustand';
// import { combine } from 'zustand/middleware';
// import { useCallback } from 'react';
import database from '@/db';
import { useShallow } from 'zustand/shallow';
import { Subscription } from 'rxjs';
// import AuthorModel from '@/db/models/Author';
import BookModel from '@/db/models/Book';
import ChapterModel from '@/db/models/Chapter';
// import { Q } from '@nozbe/watermelondb';

/**
 * Using a mapped type for books allows for O(1) lookup time, which is much more
 * performant than iterating through a large array to find a book by its ID.
 */
type BookMap = Record<string, Book>;

interface LibraryState {
  authors: Author[];
  books: BookMap; // New: Normalized book data for efficient lookups.
  setAuthors: (authors: Author[]) => void;
  // getAuthors is removed as direct access is less safe. Selectors are preferred.
  playbackProgress: Record<string, number>; // New: Stores real-time playback progress
  playbackIndex: Record<string, number>; // New: Stores real-time playback progress

  setPlaybackProgress: (bookId: string, progress: number) => void;
  setPlaybackIndex: (bookId: string, index: number) => void;
  getPlaybackProgress: (bookId: string) => number;
  getPlaybackIndex: (bookId: string) => number;
  init: () => () => void; // Function to initialize and return cleanup
  refresh: () => Promise<void>; // Force re-fetch from database
  updateBookChapterIndex: (
    bookId: string,
    chapterIndex: number,
  ) => Promise<void>;
}

// Let TypeScript infer the store type from the create call.
export const useLibraryStore: UseBoundStore<StoreApi<LibraryState>> =
  create<LibraryState>()((set, get) => ({
    authors: [],
    books: {},
    playbackProgress: {},
    playbackIndex: {},
    setAuthors: (authors: Author[]) => set({ authors }),
    setPlaybackProgress: (bookId: string, progress: number) =>
      set((state) => ({
        playbackProgress: {
          ...state.playbackProgress,
          [bookId]: progress,
        },
      })),
    setPlaybackIndex: (bookId: string, index: number) =>
      set((state) => ({
        playbackIndex: {
          ...state.playbackIndex,
          [bookId]: index,
        },
      })),
    updateBookChapterIndex: async (
      bookId: string,
      chapterIndex: number,
    ) => {
      await database.write(async () => {
        const book = await database.collections
          .get<BookModel>('books')
          .find(bookId);
        await book.update((record) => {
          record.currentChapterIndex = chapterIndex;
        });
      });
    },
    getPlaybackProgress: (bookId: string) => get().playbackProgress[bookId],
    getPlaybackIndex: (bookId: string) => get().playbackIndex[bookId],
    refresh: async () => {
      const booksCollection = database.collections.get<BookModel>('books');
      const bookModels = await booksCollection.query().fetch();

      const newBookMap: BookMap = {};
      const authorsMap = new Map<string, Book[]>();

      for (const bookModel of bookModels) {
        // Skip soft-deleted records
        if (bookModel._raw._status === 'deleted') continue;

        const authorModel = await (bookModel.author as any).fetch();
        const chapterModels = await (bookModel.chapters as any).fetch();

        const chaptersData: Chapter[] = chapterModels.map(
          (chapter: ChapterModel) => ({
            author: authorModel?.name ?? 'Unknown Author',
            bookTitle: bookModel.title,
            chapterTitle: chapter.title,
            chapterNumber: chapter.chapterNumber,
            chapterDuration: chapter.chapterDuration,
            startMs: chapter.startMs,
            url: chapter.url,
            isAutoGenerated: chapter.isAutoGenerated || false,
          }),
        );

        const bookData: Book = {
          bookId: bookModel.id,
          author: authorModel?.name ?? 'Unknown Author',
          bookTitle: bookModel.title,
          chapters: chaptersData,
          artwork: bookModel.artwork,
          artworkHeight: bookModel.artworkHeight,
          artworkWidth: bookModel.artworkWidth,
          artworkColors: {
            // average: bookModel.coverColorAverage, // DEPRECATED
            dominantAndroid: bookModel.coverColorDominant,
            vibrant: bookModel.coverColorVibrant,
            darkVibrant: bookModel.coverColorDarkVibrant,
            lightVibrant: bookModel.coverColorLightVibrant,
            muted: bookModel.coverColorMuted,
            darkMuted: bookModel.coverColorDarkMuted,
            lightMuted: bookModel.coverColorLightMuted,
          },
          bookDuration: bookModel.bookDuration,
          bookProgress: {
            currentChapterIndex: bookModel.currentChapterIndex,
            currentChapterProgress: bookModel.currentChapterProgress,
          },
          bookProgressValue: bookModel.bookProgressValue,
          hasAutoGeneratedChapters:
            bookModel.hasAutoGeneratedChapters || false,
          metadata: {
            year: bookModel.year?.toString(),
            description: bookModel.description,
            narrator: bookModel.narrator,
            genre: bookModel.genre,
            sampleRate: bookModel.sampleRate,
            bitrate: bookModel.bitrate,
            codec: bookModel.codec,
            copyright: bookModel.copyright,
            totalTrackCount: bookModel.totalTrackCount,
            ctime: bookModel.createdAt,
            mtime: bookModel.updatedAt,
          },
        };

        newBookMap[bookModel.id] = bookData;

        if (!authorsMap.has(bookData.author)) {
          authorsMap.set(bookData.author, []);
        }
        authorsMap.get(bookData.author)!.push(bookData);
      }

      const finalAuthorsData: Author[] = Array.from(authorsMap.entries())
        .map(([name, books]) => ({ name, books }))
        .sort((a, b) => a.name.localeCompare(b.name));

      set({ authors: finalAuthorsData, books: newBookMap });
    },
    init: () => {
      const booksCollection = database.collections.get<BookModel>('books');

      const subscriptions: Subscription[] = [];

      const booksSubscription = booksCollection
        .query()
        .observeWithColumns([
          'book_progress_value',
          'title',
          'narrator',
          'genre',
          'year',
          'description',
          'copyright',
          'author_id',
        ])
        .subscribe(async (changedRecords) => {
          console.log(
            `Zustand observer fired with ${changedRecords.length} changed records.`,
          );
          const { books: currentBooks } = get();

          // Create a mutable copy of the current books map
          const newBookMap = { ...currentBooks };
          let authorsNeedRebuild = false;

          // Helper function to convert a BookModel to a Book object
          const convertBookModelToBook = async (
            bookModel: BookModel,
          ): Promise<Book> => {
            // Use .fetch() which is the correct WatermelonDB API
            const authorModel = await (bookModel.author as any).fetch();
            const chapterModels = await (bookModel.chapters as any).fetch();

            const chaptersData: Chapter[] = chapterModels.map(
              (chapter: ChapterModel) => ({
                author: authorModel?.name ?? 'Unknown Author',
                bookTitle: bookModel.title,
                chapterTitle: chapter.title,
                chapterNumber: chapter.chapterNumber,
                chapterDuration: chapter.chapterDuration,
                startMs: chapter.startMs,
                url: chapter.url,
                isAutoGenerated: chapter.isAutoGenerated || false,
              }),
            );

            const bookData: Book = {
              bookId: bookModel.id,
              author: authorModel?.name ?? 'Unknown Author',
              bookTitle: bookModel.title,
              chapters: chaptersData,
              artwork: bookModel.artwork,
              artworkHeight: bookModel.artworkHeight,
              artworkWidth: bookModel.artworkWidth,
              artworkColors: {
                // average: bookModel.coverColorAverage,
                dominantAndroid: bookModel.coverColorDominant,
                vibrant: bookModel.coverColorVibrant,
                darkVibrant: bookModel.coverColorDarkVibrant,
                lightVibrant: bookModel.coverColorLightVibrant,
                muted: bookModel.coverColorMuted,
                darkMuted: bookModel.coverColorDarkMuted,
                lightMuted: bookModel.coverColorLightMuted,
              },
              bookDuration: bookModel.bookDuration,
              bookProgress: {
                currentChapterIndex: bookModel.currentChapterIndex,
                currentChapterProgress: bookModel.currentChapterProgress,
              },
              bookProgressValue: bookModel.bookProgressValue,
              hasAutoGeneratedChapters:
                bookModel.hasAutoGeneratedChapters || false,
              metadata: {
                year: bookModel.year?.toString(),
                description: bookModel.description,
                narrator: bookModel.narrator,
                genre: bookModel.genre,
                sampleRate: bookModel.sampleRate,
                bitrate: bookModel.bitrate,
                codec: bookModel.codec,
                copyright: bookModel.copyright,
                totalTrackCount: bookModel.totalTrackCount,
                ctime: bookModel.createdAt,
                mtime: bookModel.updatedAt,
              },
            };
            return bookData;
          };

          // Detect books that were hard-deleted (no longer in query results)
          // The observer returns ALL books matching the query, so any book
          // in our store that's not in changedRecords has been deleted
          const currentDbBookIds = new Set(changedRecords.map((b) => b.id));
          for (const existingId of Object.keys(currentBooks)) {
            if (!currentDbBookIds.has(existingId)) {
              delete newBookMap[existingId];
              authorsNeedRebuild = true;
            }
          }

          // Process each record from the database
          for (const bookModel of changedRecords) {
            const existingBook = newBookMap[bookModel.id];

            // If the book was soft-deleted, remove it from our map
            if (bookModel._raw._status === 'deleted') {
              delete newBookMap[bookModel.id];
              authorsNeedRebuild = true;
              continue;
            }

            // If the book is new or its author changed, we need to rebuild the authors list
            if (
              !existingBook ||
              existingBook.author !== bookModel.author.id
            ) {
              authorsNeedRebuild = true;
            }

            // Convert the updated WatermelonDB model to our Zustand state shape
            const newBookData = await convertBookModelToBook(bookModel);
            newBookMap[bookModel.id] = newBookData;
          }

          // Re-group books by author and create the final authors array.
          // This is more efficient than the previous full rebuild.
          const authorsMap = new Map<string, Book[]>();
          for (const book of Object.values(newBookMap)) {
            if (!authorsMap.has(book.author)) {
              authorsMap.set(book.author, []);
            }
            authorsMap.get(book.author)!.push(book);
          }

          const finalAuthorsData: Author[] = Array.from(
            authorsMap.entries(),
          )
            .map(([name, books]) => ({
              name,
              books,
            }))
            .sort((a, b) => a.name.localeCompare(b.name));

          set({
            authors: finalAuthorsData,
            books: newBookMap,
          });
        });

      subscriptions.push(booksSubscription);

      return () => {
        subscriptions.forEach((sub) => sub.unsubscribe());
      };
    },
    // The rest of your store logic is now inside the combine middleware
  }));

// This selector is still fine for author-level views.
export const useAuthors = () => useLibraryStore((state) => state.authors);

/**
 * Force refresh the library store from the database.
 * Call this after destructive operations that may not trigger the observer.
 */
export const refreshLibraryStore = () =>
  useLibraryStore.getState().refresh();

// This selector is inefficient and should be deprecated or updated to use the book map.
// For now, I'll leave it, but you should transition away from using it.
export const useBook = (author: string, bookTitle: string) =>
  useLibraryStore((state) => {
    const authorFound = state.authors.find((a) => a.name === author);
    return authorFound?.books.find((b) => b.bookTitle === bookTitle);
  });

/**
 * This is the new, highly performant way to get a book by its ID.
 * It directly accesses the book from the map in the store.
 */
export const useBookById = (bookId: string) => {
  return useLibraryStore((state) => state.books[bookId]);
};

/**
 * A new, more specific selector for getting just the data needed for a grid item.
 * This prevents re-renders if other book data (like chapter details) changes.
 * The `shallow` comparison is important for objects.
 */
export const useBookDisplayData = (bookId: string) =>
  useLibraryStore(
    useShallow((state) =>
      state.books[bookId]
        ? {
            bookId: state.books[bookId].bookId,
            author: state.books[bookId].author,
            bookTitle: state.books[bookId].bookTitle,
            artwork: state.books[bookId].artwork,
            artworkHeight: state.books[bookId].artworkHeight,
            artworkWidth: state.books[bookId].artworkWidth,
            currentChapterProgress:
              state.books[bookId].bookProgress.currentChapterProgress,
          }
        : undefined,
    ),
  );
