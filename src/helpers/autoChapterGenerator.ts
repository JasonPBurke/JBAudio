import database from '@/db';
import BookModel from '@/db/models/Book';
import ChapterModel from '@/db/models/Chapter';
import { Q } from '@nozbe/watermelondb';
import {
  getAutoChapterInterval,
  getBooksWithoutChapterData,
} from '@/db/settingsQueries';

export interface GeneratedChapter {
  title: string;
  chapterNumber: number;
  chapterDuration: number;
  startMs: number;
  isAutoGenerated: boolean;
}

/**
 * Generates auto-chapter data based on book duration and interval.
 * Chapter titles follow the pattern: "Track 01", "Track 02", etc.
 * The last chapter gets the remaining duration.
 *
 * @param bookDurationSeconds - Total book duration in seconds
 * @param intervalMinutes - Chapter interval in minutes (30 or 60)
 * @returns Array of generated chapter data
 */
export function generateAutoChapters(
  bookDurationSeconds: number,
  intervalMinutes: number
): GeneratedChapter[] {
  const intervalMs = intervalMinutes * 60 * 1000;
  const bookDurationMs = bookDurationSeconds * 1000;
  const chapters: GeneratedChapter[] = [];

  let currentStartMs = 0;
  let chapterNumber = 1;

  while (currentStartMs < bookDurationMs) {
    const remainingMs = bookDurationMs - currentStartMs;
    const chapterDurationMs = Math.min(intervalMs, remainingMs);

    chapters.push({
      title: `Track ${String(chapterNumber).padStart(2, '0')}`,
      chapterNumber,
      startMs: currentStartMs,
      chapterDuration: chapterDurationMs / 1000, // Convert back to seconds
      isAutoGenerated: true,
    });

    currentStartMs += chapterDurationMs;
    chapterNumber++;
  }

  return chapters;
}

/**
 * Applies auto-generated chapters to all existing books that lack chapter data.
 * Uses the current auto_chapter_interval setting.
 *
 * @returns Number of books that had chapters generated
 */
export async function applyAutoChaptersToExistingBooks(): Promise<number> {
  const interval = await getAutoChapterInterval();
  if (!interval) {
    return 0;
  }

  const booksWithoutChapters = await getBooksWithoutChapterData();

  if (booksWithoutChapters.length === 0) {
    return 0;
  }

  await database.write(async () => {
    const batchOperations: any[] = [];

    for (const book of booksWithoutChapters) {
      // Delete any existing single chapter
      const existingChapters = await database
        .get<ChapterModel>('chapters')
        .query(Q.where('book_id', book.id))
        .fetch();

      for (const chapter of existingChapters) {
        batchOperations.push(chapter.prepareDestroyPermanently());
      }

      // Generate new auto-chapters
      const generatedChapters = generateAutoChapters(book.bookDuration, interval);

      // Get the first chapter's URL to use for all generated chapters
      // (since all chapters point to the same audio file for single-file books)
      const chapterUrl = existingChapters[0]?.url || '';

      for (const chapterData of generatedChapters) {
        const newChapter = database
          .get<ChapterModel>('chapters')
          .prepareCreate((chapter: ChapterModel) => {
            chapter.title = chapterData.title;
            chapter.chapterNumber = chapterData.chapterNumber;
            chapter.chapterDuration = chapterData.chapterDuration;
            chapter.startMs = chapterData.startMs;
            chapter.url = chapterUrl;
            chapter.isAutoGenerated = true;
            (chapter._raw as any).book_id = book.id;
          });
        batchOperations.push(newChapter);
      }

      // Mark the book as having auto-generated chapters
      batchOperations.push(
        book.prepareUpdate((b: BookModel) => {
          b.hasAutoGeneratedChapters = true;
        })
      );
    }

    await database.batch(batchOperations);
  });

  return booksWithoutChapters.length;
}

/**
 * Removes auto-generated chapters from a book and reverts to a single chapter
 * spanning the entire book duration.
 *
 * @param bookId - The WatermelonDB ID of the book
 */
export async function removeAutoChapters(bookId: string): Promise<void> {
  await database.write(async () => {
    const book = await database.get<BookModel>('books').find(bookId);

    if (!book.hasAutoGeneratedChapters) {
      return;
    }

    const batchOperations: any[] = [];

    // Get existing chapters to preserve the URL
    const existingChapters = await database
      .get<ChapterModel>('chapters')
      .query(Q.where('book_id', bookId))
      .fetch();

    const chapterUrl = existingChapters[0]?.url || '';

    // Delete all existing auto-generated chapters
    for (const chapter of existingChapters) {
      batchOperations.push(chapter.prepareDestroyPermanently());
    }

    // Create a single chapter spanning the entire book
    const singleChapter = database
      .get<ChapterModel>('chapters')
      .prepareCreate((chapter: ChapterModel) => {
        chapter.title = book.title || 'Full Book';
        chapter.chapterNumber = 1;
        chapter.chapterDuration = book.bookDuration;
        chapter.startMs = 0;
        chapter.url = chapterUrl;
        chapter.isAutoGenerated = false;
        (chapter._raw as any).book_id = bookId;
      });
    batchOperations.push(singleChapter);

    // Clear the auto-generated flag on the book
    batchOperations.push(
      book.prepareUpdate((b: BookModel) => {
        b.hasAutoGeneratedChapters = false;
      })
    );

    await database.batch(batchOperations);
  });
}

/**
 * Checks if a book needs auto-chapter generation.
 * A book needs auto-chapters if:
 * - It has no chapters, or only a single chapter
 * - It doesn't already have auto-generated chapters
 * - The auto-chapter setting is enabled
 *
 * @param chapterCount - Number of chapters the book currently has
 * @param hasAutoGeneratedChapters - Whether the book already has auto-generated chapters
 * @param autoChapterInterval - The current auto-chapter interval setting (null if disabled)
 * @returns Whether auto-chapters should be generated
 */
export function shouldGenerateAutoChapters(
  chapterCount: number,
  hasAutoGeneratedChapters: boolean | null | undefined,
  autoChapterInterval: number | null
): boolean {
  // Setting must be enabled
  if (!autoChapterInterval) {
    return false;
  }

  // Don't regenerate if already has auto-generated chapters
  if (hasAutoGeneratedChapters) {
    return false;
  }

  // Only generate for books without real chapter data
  // (no chapters or single chapter spanning the whole book)
  return chapterCount <= 1;
}
